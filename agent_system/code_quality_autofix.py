#!/usr/bin/env python3

import os
import re
import sys
import argparse
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress
import autopep8

console = Console()


def fix_import_errors(file_path):
    """Fix import errors in the backend code."""
    with open(file_path, 'r') as f:
        content = f.read()

    # Fix 'ImportError: No module named 'app'' by adjusting import paths
    if 'backend/app/' in str(file_path):
        # Add path adjustments for relative imports
        modified = re.sub(r'from app import', r'from backend.app import', content)
        modified = re.sub(r'from app\.', r'from backend.app.', modified)
        modified = re.sub(r'import app\.', r'import backend.app.', modified)

        # Only write if changes were made
        if modified != content:
            with open(file_path, 'w') as f:
                f.write(modified)
            return True
    return False


def fix_line_length(file_path, max_length=120):
    """Fix lines that exceed the maximum length."""
    if file_path.suffix == '.py':
        try:
            with open(file_path, 'r') as f:
                content = f.read()

            result = autopep8.fix_code(
                content,
                options={'max_line_length': max_length, 'aggressive': 1}
            )

            with open(file_path, 'w') as f:
                f.write(result)
            return True
        except Exception as e:
            console.print(f"Error fixing line length in {file_path}: {e}", style="bold red")
    return False


def replace_print_with_logging(file_path):
    """Replace print statements with proper logging."""
    if file_path.suffix == '.py':
        with open(file_path, 'r') as f:
            content = f.read()

        # Check if logging is already imported
        has_logging_import = re.search(r'import\s+logging', content) is not None

        # Replace print statements with logging
        print_pattern = r'print\((.*?)\)'
        matches = re.findall(print_pattern, content)

        if matches:
            # Add logging import if needed
            if not has_logging_import:
                content = "import logging\n" + content
                # Add logger configuration
                logger_setup = "\nlogger = logging.getLogger(__name__)\n"
                # Find the right spot to insert the logger
                import_section_end = re.search(r'(^import.*?\n)+', content, re.MULTILINE)
                if import_section_end:
                    pos = import_section_end.end()
                    content = content[:pos] + logger_setup + content[pos:]
                else:
                    content = content + logger_setup

            # Replace each print statement
            modified = content
            for match in matches:
                original = f"logger.info({match})"
                replacement = f"logger.info({match})"
                modified = modified.replace(original, replacement)

            # Only write if changes were made
            if modified != content:
                with open(file_path, 'w') as f:
                    f.write(modified)
                return True
    return False


def add_init_files():
    """Add missing __init__.py files to ensure proper imports."""
    backend_dir = Path('backend')
    count = 0

    if backend_dir.exists() and backend_dir.is_dir():
        for dirpath, _, _ in os.walk(backend_dir):
            init_file = os.path.join(dirpath, '__init__.py')
            if not os.path.exists(init_file):
                with open(init_file, 'w') as f:
                    f.write('# Generated by code_quality_autofix.py\n')
                count += 1

    return count


def fix_files_in_directory(directory, fix_imports=True, fix_line_lengths=True, fix_prints=True):
    """Fix issues in all files in a directory."""
    directory_path = Path(directory)
    if not directory_path.exists():
        console.print(f"Directory {directory} does not exist", style="bold red")
        return 0, 0

    python_files = list(directory_path.glob('**/*.py'))
    ts_files = list(directory_path.glob('**/*.ts')) + list(directory_path.glob('**/*.tsx'))
    all_files = python_files + ts_files

    fixed_count = 0

    with Progress() as progress:
        task = progress.add_task("[cyan]Fixing files...", total=len(all_files))

        for file_path in all_files:
            changes_made = False
            file_str = str(file_path)

            if fix_imports and file_path.suffix == '.py':
                if fix_import_errors(file_path):
                    changes_made = True

            if fix_line_lengths:
                if fix_line_length(file_path):
                    changes_made = True

            if fix_prints and file_path.suffix == '.py':
                if replace_print_with_logging(file_path):
                    changes_made = True

            if changes_made:
                fixed_count += 1

            progress.update(task, advance=1)

    # Add missing __init__.py files
    init_count = 0
    if fix_imports:
        init_count = add_init_files()

    return fixed_count, init_count


def main():
    parser = argparse.ArgumentParser(description='Automatically fix common code quality issues.')
    parser.add_argument('--directory', type=str, default='.', help='Directory to fix')
    parser.add_argument('--no-imports', action='store_true', help='Skip fixing import errors')
    parser.add_argument('--no-line-length', action='store_true', help='Skip fixing line length issues')
    parser.add_argument('--no-prints', action='store_true', help='Skip replacing print statements with logging')

    args = parser.parse_args()

    console.print(Panel(f"[bold]Automatically fixing code quality issues in {args.directory}[/bold]",
                        expand=False))

    fixed_count, init_count = fix_files_in_directory(
        args.directory,
        fix_imports=not args.no_imports,
        fix_line_lengths=not args.no_line_length,
        fix_prints=not args.no_prints
    )

    if fixed_count > 0 or init_count > 0:
        console.print(Panel(f"[bold green]Fixed {fixed_count} files with quality issues[/bold green]",
                            expand=False))
        if init_count > 0:
            console.print(f"Added {init_count} missing __init__.py files")
        console.print("[green]Run the validation script again to check remaining issues[/green]")
    else:
        console.print(Panel("[bold yellow]No issues fixed - all files may already meet standards[/bold yellow]",
                            expand=False))


if __name__ == "__main__":
    main()
